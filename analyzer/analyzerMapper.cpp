#include <iostream>
#include <thread>
#include <sstream>
#include <fstream>

#include "analyzerMapper.h"

// The base name of chunk files generated by mappers
const string CAnalyzerMapper::CHUNK_FILE_NAME_BASE = "chunk";

CAnalyzerMapper::CAnalyzerMapper(int index, string workingPath, int chunkFileSize)
    : m_index(index), m_thread(&CAnalyzerMapper::mapTask, this),
      m_totalBatchCount(0), m_workingPath(workingPath), m_chunkFileSize(chunkFileSize)
{
    m_bBatchDone.store(false);
    m_bClose.store(false);
}

//////////////////////////////////////////////////////////////////////////
// Description: Write messages to the queue for the mapper to process
//////////////////////////////////////////////////////////////////////////
void CAnalyzerMapper::addMessages(const string &messages)
{
    std::lock_guard<mutex> lg(m_mutexQueue);
    m_queueForMessages.push(messages);
}

//////////////////////////////////////////////////////////////////////////
// Description: The routine function for the mapper task thread.
//////////////////////////////////////////////////////////////////////////
void CAnalyzerMapper::mapTask()
{
    while (true)
    {
        if (m_bClose.load())
        {
            break;
        }

        string lines;
        {
            std::lock_guard<mutex> lg(m_mutexQueue);
            if (m_queueForMessages.size() > 0)
            {
                m_bBatchDone.store(false);

                lines = m_queueForMessages.front();
                m_queueForMessages.pop();

                cout << "Mapper " << m_index << " lines size: " << lines.size() << "\n";
            }
        }

        if (lines.empty())
        {
            std::this_thread::sleep_for(std::chrono::milliseconds(200));
        }
        else
        {
            istringstream iss(lines);
            string line;
            while (std::getline(iss, line))
            {
                CAnalyzeItem item(line, false);
                m_minPQ.push(item);
            }

            // Write the temporarily results to chunk files
            cout << "Mapper " << m_index << " start writing into chunk files...\n";
            string contentsToWrite;
            int chunkIndex = 0;
            int batchIndex = m_totalBatchCount;
            while (!m_minPQ.empty())
            {
                auto item = m_minPQ.top();
                m_minPQ.pop();

                // Serialize the item and write to chunk files
                contentsToWrite += item.serialize();
                if (contentsToWrite.size() >= m_chunkFileSize)
                {
                    ofstream fsCSVFile;
                    fsCSVFile.open(getChunkFileName(batchIndex, chunkIndex), ios::out);
                    fsCSVFile << contentsToWrite;
                    fsCSVFile.close();
                    contentsToWrite.clear();
                    chunkIndex++;
                }
            }

            m_bBatchDone.store(true);
            m_totalBatchCount++;
            cout << "Mapper " << m_index << " finished processing\n";
        }
    }
}

//////////////////////////////////////////////////////////////////////////
// Description: Stop the mapper task thread.
//////////////////////////////////////////////////////////////////////////
void CAnalyzerMapper::stopTask()
{
    m_bClose.store(true);
    m_thread.join();
}

//////////////////////////////////////////////////////////////////////////
// Description: Get the chunk file name based on mapper index ID, batch Index and chunk index.
// Parameter:   batchIndex: batch index
//              chunkIndex: chunk index
//////////////////////////////////////////////////////////////////////////
string CAnalyzerMapper::getChunkFileName(int batchIndex, int chunkIndex)
{
    return m_workingPath + CAnalyzerMapper::CHUNK_FILE_NAME_BASE + "_" + to_string(m_index) + "_" + to_string(batchIndex) + "_" +
           to_string(chunkIndex) + ".csv";
}
